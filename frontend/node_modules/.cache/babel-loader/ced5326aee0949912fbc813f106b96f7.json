{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = void 0;\n\nvar _utils = _interopRequireWildcard(require(\"./utils\"));\n\nvar _core = require(\"./core\");\n\nvar _is = _interopRequireDefault(require(\"../validators/is\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\n(0, _utils.default)(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, _core.patternLikeCommon, {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, _core.patternLikeCommon, {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, _core.functionCommon, {}, _core.functionTypeAnnotationCommon, {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    }\n  })\n});\n(0, _utils.default)(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"TSDeclareMethod\", \"TSIndexSignature\")))\n    }\n  }\n});\n(0, _utils.default)(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"FunctionDeclaration\", \"TSDeclareFunction\", \"ClassDeclaration\", \"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n      }, function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      })\n    },\n    specifiers: {\n      default: [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\n(0, _utils.default)(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\");\n        return function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        let property;\n\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n\n          case \"new\":\n            property = \"target\";\n            break;\n\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      })\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = {\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"Expression\"))\n  }\n};\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = Object.assign({}, _core.functionCommon, {}, classMethodOrPropertyCommon, {\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\n(0, _utils.default)(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, {}, _core.functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\n(0, _utils.default)(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, _core.patternLikeCommon, {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\n(0, _utils.default)(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"Super\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\n(0, _utils.default)(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});","map":{"version":3,"sources":["/workspace/covexit/frontend/node_modules/@babel/types/lib/definitions/es2015.js"],"names":["Object","defineProperty","exports","value","classMethodOrDeclareMethodCommon","classMethodOrPropertyCommon","_utils","_interopRequireWildcard","require","_core","_is","_interopRequireDefault","obj","__esModule","default","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","visitor","builder","aliases","fields","assign","patternLikeCommon","left","validate","assertNodeType","right","decorators","chain","assertValueType","assertEach","optional","elements","assertNodeOrValueType","functionCommon","functionTypeAnnotationCommon","expression","body","id","typeParameters","superClass","superTypeParameters","implements","inherits","declare","abstract","identifier","parent","node","process","env","BABEL_TYPES_8_BREAKING","source","declaration","val","specifiers","length","TypeError","sourced","sourceless","validator","exportKind","validateOptional","assertOneOf","local","exported","lval","await","importKind","imported","meta","property","name","accessibility","static","computed","normal","kind","access","properties","deprecatedAlias","argument","tag","quasi","assertShape","raw","cooked","tail","quasis","expressions","type","delegate"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = void 0;\n\nvar _utils = _interopRequireWildcard(require(\"./utils\"));\n\nvar _core = require(\"./core\");\n\nvar _is = _interopRequireDefault(require(\"../validators/is\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n(0, _utils.default)(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, _core.patternLikeCommon, {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, _core.patternLikeCommon, {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, _core.functionCommon, {}, _core.functionTypeAnnotationCommon, {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    }\n  })\n});\n(0, _utils.default)(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"TSDeclareMethod\", \"TSIndexSignature\")))\n    }\n  }\n});\n(0, _utils.default)(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"FunctionDeclaration\", \"TSDeclareFunction\", \"ClassDeclaration\", \"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n      }, function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      })\n    },\n    specifiers: {\n      default: [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\n(0, _utils.default)(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\");\n        return function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        let property;\n\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n\n          case \"new\":\n            property = \"target\";\n            break;\n\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      })\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = {\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"Expression\"))\n  }\n};\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = Object.assign({}, _core.functionCommon, {}, classMethodOrPropertyCommon, {\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\n(0, _utils.default)(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, {}, _core.functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\n(0, _utils.default)(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, _core.patternLikeCommon, {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\n(0, _utils.default)(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"Super\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\n(0, _utils.default)(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});"]},"metadata":{},"sourceType":"script"}