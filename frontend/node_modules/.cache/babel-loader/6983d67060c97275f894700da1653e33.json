{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeTypeDuplicates;\n\nvar _generated = require(\"../../validators/generated\");\n\nfunction removeTypeDuplicates(nodes) {\n  const generics = {};\n  const bases = {};\n  const typeGroups = [];\n  const types = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    if ((0, _generated.isAnyTypeAnnotation)(node)) {\n      return [node];\n    }\n\n    if ((0, _generated.isFlowBaseAnnotation)(node)) {\n      bases[node.type] = node;\n      continue;\n    }\n\n    if ((0, _generated.isUnionTypeAnnotation)(node)) {\n      if (typeGroups.indexOf(node.types) < 0) {\n        nodes = nodes.concat(node.types);\n        typeGroups.push(node.types);\n      }\n\n      continue;\n    }\n\n    if ((0, _generated.isGenericTypeAnnotation)(node)) {\n      const name = node.id.name;\n\n      if (generics[name]) {\n        let existing = generics[name];\n\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics[name] = node;\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  for (const type of Object.keys(bases)) {\n    types.push(bases[type]);\n  }\n\n  for (const name of Object.keys(generics)) {\n    types.push(generics[name]);\n  }\n\n  return types;\n}","map":{"version":3,"sources":["/workspace/covexit/frontend/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"],"names":["Object","defineProperty","exports","value","default","removeTypeDuplicates","_generated","require","nodes","generics","bases","typeGroups","types","i","length","node","indexOf","isAnyTypeAnnotation","isFlowBaseAnnotation","type","isUnionTypeAnnotation","concat","push","isGenericTypeAnnotation","name","id","existing","typeParameters","params","keys"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,oBAAlB;;AAEA,IAAIC,UAAU,GAAGC,OAAO,CAAC,4BAAD,CAAxB;;AAEA,SAASF,oBAAT,CAA8BG,KAA9B,EAAqC;AACnC,QAAMC,QAAQ,GAAG,EAAjB;AACA,QAAMC,KAAK,GAAG,EAAd;AACA,QAAMC,UAAU,GAAG,EAAnB;AACA,QAAMC,KAAK,GAAG,EAAd;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAAK,CAACM,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACrC,UAAME,IAAI,GAAGP,KAAK,CAACK,CAAD,CAAlB;AACA,QAAI,CAACE,IAAL,EAAW;;AAEX,QAAIH,KAAK,CAACI,OAAN,CAAcD,IAAd,KAAuB,CAA3B,EAA8B;AAC5B;AACD;;AAED,QAAI,CAAC,GAAGT,UAAU,CAACW,mBAAf,EAAoCF,IAApC,CAAJ,EAA+C;AAC7C,aAAO,CAACA,IAAD,CAAP;AACD;;AAED,QAAI,CAAC,GAAGT,UAAU,CAACY,oBAAf,EAAqCH,IAArC,CAAJ,EAAgD;AAC9CL,MAAAA,KAAK,CAACK,IAAI,CAACI,IAAN,CAAL,GAAmBJ,IAAnB;AACA;AACD;;AAED,QAAI,CAAC,GAAGT,UAAU,CAACc,qBAAf,EAAsCL,IAAtC,CAAJ,EAAiD;AAC/C,UAAIJ,UAAU,CAACK,OAAX,CAAmBD,IAAI,CAACH,KAAxB,IAAiC,CAArC,EAAwC;AACtCJ,QAAAA,KAAK,GAAGA,KAAK,CAACa,MAAN,CAAaN,IAAI,CAACH,KAAlB,CAAR;AACAD,QAAAA,UAAU,CAACW,IAAX,CAAgBP,IAAI,CAACH,KAArB;AACD;;AAED;AACD;;AAED,QAAI,CAAC,GAAGN,UAAU,CAACiB,uBAAf,EAAwCR,IAAxC,CAAJ,EAAmD;AACjD,YAAMS,IAAI,GAAGT,IAAI,CAACU,EAAL,CAAQD,IAArB;;AAEA,UAAIf,QAAQ,CAACe,IAAD,CAAZ,EAAoB;AAClB,YAAIE,QAAQ,GAAGjB,QAAQ,CAACe,IAAD,CAAvB;;AAEA,YAAIE,QAAQ,CAACC,cAAb,EAA6B;AAC3B,cAAIZ,IAAI,CAACY,cAAT,EAAyB;AACvBD,YAAAA,QAAQ,CAACC,cAAT,CAAwBC,MAAxB,GAAiCvB,oBAAoB,CAACqB,QAAQ,CAACC,cAAT,CAAwBC,MAAxB,CAA+BP,MAA/B,CAAsCN,IAAI,CAACY,cAAL,CAAoBC,MAA1D,CAAD,CAArD;AACD;AACF,SAJD,MAIO;AACLF,UAAAA,QAAQ,GAAGX,IAAI,CAACY,cAAhB;AACD;AACF,OAVD,MAUO;AACLlB,QAAAA,QAAQ,CAACe,IAAD,CAAR,GAAiBT,IAAjB;AACD;;AAED;AACD;;AAEDH,IAAAA,KAAK,CAACU,IAAN,CAAWP,IAAX;AACD;;AAED,OAAK,MAAMI,IAAX,IAAmBnB,MAAM,CAAC6B,IAAP,CAAYnB,KAAZ,CAAnB,EAAuC;AACrCE,IAAAA,KAAK,CAACU,IAAN,CAAWZ,KAAK,CAACS,IAAD,CAAhB;AACD;;AAED,OAAK,MAAMK,IAAX,IAAmBxB,MAAM,CAAC6B,IAAP,CAAYpB,QAAZ,CAAnB,EAA0C;AACxCG,IAAAA,KAAK,CAACU,IAAN,CAAWb,QAAQ,CAACe,IAAD,CAAnB;AACD;;AAED,SAAOZ,KAAP;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeTypeDuplicates;\n\nvar _generated = require(\"../../validators/generated\");\n\nfunction removeTypeDuplicates(nodes) {\n  const generics = {};\n  const bases = {};\n  const typeGroups = [];\n  const types = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    if ((0, _generated.isAnyTypeAnnotation)(node)) {\n      return [node];\n    }\n\n    if ((0, _generated.isFlowBaseAnnotation)(node)) {\n      bases[node.type] = node;\n      continue;\n    }\n\n    if ((0, _generated.isUnionTypeAnnotation)(node)) {\n      if (typeGroups.indexOf(node.types) < 0) {\n        nodes = nodes.concat(node.types);\n        typeGroups.push(node.types);\n      }\n\n      continue;\n    }\n\n    if ((0, _generated.isGenericTypeAnnotation)(node)) {\n      const name = node.id.name;\n\n      if (generics[name]) {\n        let existing = generics[name];\n\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics[name] = node;\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  for (const type of Object.keys(bases)) {\n    types.push(bases[type]);\n  }\n\n  for (const name of Object.keys(generics)) {\n    types.push(generics[name]);\n  }\n\n  return types;\n}"]},"metadata":{},"sourceType":"script"}