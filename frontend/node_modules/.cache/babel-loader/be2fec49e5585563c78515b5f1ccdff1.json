{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;\n\nvar _is = _interopRequireDefault(require(\"../validators/is\"));\n\nvar _isValidIdentifier = _interopRequireDefault(require(\"../validators/isValidIdentifier\"));\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _constants = require(\"../constants\");\n\nvar _utils = _interopRequireWildcard(require(\"./utils\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n(0, _utils.default)(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\n(0, _utils.default)(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\n(0, _utils.default)(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\n(0, _utils.default)(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\n(0, _utils.default)(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\n(0, _utils.default)(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\n(0, _utils.default)(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    }\n  }\n});\n(0, _utils.default)(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n};\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = Object.assign({}, functionCommon, {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\n(0, _utils.default)(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon, {}, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, {}, functionTypeAnnotationCommon, {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\nconst patternLikeCommon = {\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n  }\n};\nexports.patternLikeCommon = patternLikeCommon;\n(0, _utils.default)(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      })\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n\n});\n(0, _utils.default)(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }),\n      default: \"\"\n    }\n  }\n});\n(0, _utils.default)(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\n(0, _utils.default)(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\n(0, _utils.default)(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\n(0, _utils.default)(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\n(0, _utils.default)(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon, {}, functionTypeAnnotationCommon, {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\n(0, _utils.default)(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\n(0, _utils.default)(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon, {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"MemberExpression\")\n    }\n  }),\n\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n\n    if (parent[listKey].length > index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\n(0, _utils.default)(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\n(0, _utils.default)(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      })\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\n(0, _utils.default)(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\n(0, _utils.default)(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});","map":{"version":3,"sources":["/workspace/covexit/frontend/node_modules/@babel/types/lib/definitions/core.js"],"names":["Object","defineProperty","exports","value","patternLikeCommon","functionDeclarationCommon","functionTypeAnnotationCommon","functionCommon","_is","_interopRequireDefault","require","_isValidIdentifier","_helperValidatorIdentifier","_constants","_utils","_interopRequireWildcard","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","fields","elements","validate","chain","assertValueType","assertEach","assertNodeOrValueType","process","env","BABEL_TYPES_8_BREAKING","undefined","visitor","aliases","operator","identifier","assertOneOf","ASSIGNMENT_OPERATORS","pattern","node","val","validator","left","assertNodeType","right","builder","BINARY_OPERATORS","directives","body","label","optional","assign","callee","arguments","typeArguments","typeParameters","param","test","consequent","alternate","expression","program","init","update","params","generator","async","returnType","declare","id","parent","inherits","typeAnnotation","decorators","name","TypeError","match","exec","parentKey","nonComp","computed","imported","meta","isKeyword","isReservedWord","deprecatedAlias","flags","invalid","LOGICAL_OPERATORS","object","property","normal","sourceFile","sourceType","interpreter","properties","kind","shorthand","argument","Error","listKey","index","length","expressions","discriminant","cases","block","handler","finalizer","prefix","UNARY_OPERATORS","UPDATE_OPERATORS","declarations","type","without","definite"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;\n\nvar _is = _interopRequireDefault(require(\"../validators/is\"));\n\nvar _isValidIdentifier = _interopRequireDefault(require(\"../validators/isValidIdentifier\"));\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _constants = require(\"../constants\");\n\nvar _utils = _interopRequireWildcard(require(\"./utils\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _utils.default)(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\n(0, _utils.default)(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\n(0, _utils.default)(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\n(0, _utils.default)(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\n(0, _utils.default)(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\n(0, _utils.default)(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\n(0, _utils.default)(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    }\n  }\n});\n(0, _utils.default)(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n};\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = Object.assign({}, functionCommon, {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\n(0, _utils.default)(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon, {}, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, {}, functionTypeAnnotationCommon, {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\nconst patternLikeCommon = {\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n  }\n};\nexports.patternLikeCommon = patternLikeCommon;\n(0, _utils.default)(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      })\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n\n});\n(0, _utils.default)(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }),\n      default: \"\"\n    }\n  }\n});\n(0, _utils.default)(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\n(0, _utils.default)(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\n(0, _utils.default)(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\n(0, _utils.default)(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\n(0, _utils.default)(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon, {}, functionTypeAnnotationCommon, {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\n(0, _utils.default)(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\n(0, _utils.default)(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon, {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"MemberExpression\")\n    }\n  }),\n\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n\n    if (parent[listKey].length > index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\n(0, _utils.default)(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\n(0, _utils.default)(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      })\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\n(0, _utils.default)(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\n(0, _utils.default)(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});"]},"metadata":{},"sourceType":"script"}