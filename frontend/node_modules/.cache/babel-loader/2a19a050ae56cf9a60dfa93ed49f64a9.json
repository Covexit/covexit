{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneNode;\n\nvar _definitions = require(\"../definitions\");\n\nconst has = Function.call.bind(Object.prototype.hasOwnProperty);\n\nfunction cloneIfNode(obj, deep, withoutLoc) {\n  if (obj && typeof obj.type === \"string\") {\n    return cloneNode(obj, deep, withoutLoc);\n  }\n\n  return obj;\n}\n\nfunction cloneIfNodeOrArray(obj, deep, withoutLoc) {\n  if (Array.isArray(obj)) {\n    return obj.map(node => cloneIfNode(node, deep, withoutLoc));\n  }\n\n  return cloneIfNode(obj, deep, withoutLoc);\n}\n\nfunction cloneNode(node, deep = true, withoutLoc = false) {\n  if (!node) return node;\n  const {\n    type\n  } = node;\n  const newNode = {\n    type\n  };\n\n  if (type === \"Identifier\") {\n    newNode.name = node.name;\n\n    if (has(node, \"optional\") && typeof node.optional === \"boolean\") {\n      newNode.optional = node.optional;\n    }\n\n    if (has(node, \"typeAnnotation\")) {\n      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;\n    }\n  } else if (!has(_definitions.NODE_FIELDS, type)) {\n    throw new Error(`Unknown node type: \"${type}\"`);\n  } else {\n    for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {\n      if (has(node, field)) {\n        if (deep) {\n          newNode[field] = type === \"File\" && field === \"comments\" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);\n        } else {\n          newNode[field] = node[field];\n        }\n      }\n    }\n  }\n\n  if (has(node, \"loc\")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n\n  if (has(node, \"leadingComments\")) {\n    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);\n  }\n\n  if (has(node, \"innerComments\")) {\n    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);\n  }\n\n  if (has(node, \"trailingComments\")) {\n    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);\n  }\n\n  if (has(node, \"extra\")) {\n    newNode.extra = Object.assign({}, node.extra);\n  }\n\n  return newNode;\n}\n\nfunction cloneCommentsWithoutLoc(comments) {\n  return comments.map(({\n    type,\n    value\n  }) => ({\n    type,\n    value,\n    loc: null\n  }));\n}\n\nfunction maybeCloneComments(comments, deep, withoutLoc) {\n  return deep && withoutLoc ? cloneCommentsWithoutLoc(comments) : comments;\n}","map":{"version":3,"sources":["/workspace/covexit/frontend/node_modules/@babel/types/lib/clone/cloneNode.js"],"names":["Object","defineProperty","exports","value","default","cloneNode","_definitions","require","has","Function","call","bind","prototype","hasOwnProperty","cloneIfNode","obj","deep","withoutLoc","type","cloneIfNodeOrArray","Array","isArray","map","node","newNode","name","optional","typeAnnotation","NODE_FIELDS","Error","field","keys","maybeCloneComments","comments","loc","leadingComments","innerComments","trailingComments","extra","assign","cloneCommentsWithoutLoc"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneNode;\n\nvar _definitions = require(\"../definitions\");\n\nconst has = Function.call.bind(Object.prototype.hasOwnProperty);\n\nfunction cloneIfNode(obj, deep, withoutLoc) {\n  if (obj && typeof obj.type === \"string\") {\n    return cloneNode(obj, deep, withoutLoc);\n  }\n\n  return obj;\n}\n\nfunction cloneIfNodeOrArray(obj, deep, withoutLoc) {\n  if (Array.isArray(obj)) {\n    return obj.map(node => cloneIfNode(node, deep, withoutLoc));\n  }\n\n  return cloneIfNode(obj, deep, withoutLoc);\n}\n\nfunction cloneNode(node, deep = true, withoutLoc = false) {\n  if (!node) return node;\n  const {\n    type\n  } = node;\n  const newNode = {\n    type\n  };\n\n  if (type === \"Identifier\") {\n    newNode.name = node.name;\n\n    if (has(node, \"optional\") && typeof node.optional === \"boolean\") {\n      newNode.optional = node.optional;\n    }\n\n    if (has(node, \"typeAnnotation\")) {\n      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;\n    }\n  } else if (!has(_definitions.NODE_FIELDS, type)) {\n    throw new Error(`Unknown node type: \"${type}\"`);\n  } else {\n    for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {\n      if (has(node, field)) {\n        if (deep) {\n          newNode[field] = type === \"File\" && field === \"comments\" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);\n        } else {\n          newNode[field] = node[field];\n        }\n      }\n    }\n  }\n\n  if (has(node, \"loc\")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n\n  if (has(node, \"leadingComments\")) {\n    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);\n  }\n\n  if (has(node, \"innerComments\")) {\n    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);\n  }\n\n  if (has(node, \"trailingComments\")) {\n    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);\n  }\n\n  if (has(node, \"extra\")) {\n    newNode.extra = Object.assign({}, node.extra);\n  }\n\n  return newNode;\n}\n\nfunction cloneCommentsWithoutLoc(comments) {\n  return comments.map(({\n    type,\n    value\n  }) => ({\n    type,\n    value,\n    loc: null\n  }));\n}\n\nfunction maybeCloneComments(comments, deep, withoutLoc) {\n  return deep && withoutLoc ? cloneCommentsWithoutLoc(comments) : comments;\n}"]},"metadata":{},"sourceType":"script"}